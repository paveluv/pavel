-------------------------------------------------------------------------------
-- | Types for interfacing with XNU. Only types that are used to prepare the
-- input, or interpret the output of XNU system calls should appear here.
--
-- Autogenerated enums are placed in a non-exposed Pavel.Xnu.Types.CEnums
-- (and reëxported here) because it needs to be processed by a different
-- preprocessor (c2hs vs hsc2hs).
--
-- The "C" prefix should be only used if the type is involved in capi calls.
-- If in doubt, don't add "C" prefix. It can always be added later.
--
-- Struct field names, enum and constant names are preserved to make it easier
-- to cross reference them with man pages and C source.
--
-- Struct and enum names are converted to UpperCamelCase, with word boundaries
-- chosen intelligently. Established abbreviations (used in multiple places for
-- years) go as a single word, so they get only one capital letter
-- (Kauth, not KAuth; Id, not ID; Xnu, not XNU; etc).
--
-- This module should avoid defining types that are already defined in
-- 'System.Posix.Types' and other standard libraries.
-------------------------------------------------------------------------------

module Pavel.Xnu.Types
  ( Base2(..)
  , FsId(..)
  , FsObjId(..)
  , TextEncoding(..)
  , DarwinTime(..)
  , TimeSpec(..)
  , RawFinderInfo
  , FileFlags
  , Guid(..)
  , KauthAce(..)
  , KauthAcl(..)
  , KauthFilesec(..)
  , peekKauthAcl
  , peekKauthFilesec
  -- | * Reëxported from CEnums.hs
  , FsOpt(..)
  , VType(..)
  , VTagType(..)
  , FileFlag(..)
  ) where

import Control.Monad
import Data.Char
import qualified Data.ByteString.Char8 as BS
import Data.Int
import Data.Hex
import Data.Word
import Foreign.C.String
import Foreign.Marshal.Utils
import Foreign.Ptr
import Foreign.Storable
import Numeric

import Pavel.EnumBitFlags
import Pavel.SafeBuf
import Pavel.Xnu.Types.CEnums

-- this needs to be included first for sys/acl.h to work
#include <sys/types.h>

#include <sys/_types/_fsid_t.h>
#include <sys/_types/_timespec.h>
#include <sys/acl.h>
#include <sys/attr.h>

-- | File system id type.
-- Corresponds to @struct fsid@ defined in
-- @sys/_types/_fsid_t.h@.
-- Returned by 'getAttrList' for @ATTR_CMN_FSID@.
data FsId =
  FsId !Int32 !Int32
  deriving (Eq, Ord, Read, Show)

instance Storable FsId where
  sizeOf _ = #{size struct fsid}
  alignment _ = #{alignment struct fsid}
  peek ptr = do
    first <- peek (#{ptr struct fsid, val[0]} ptr)
    second <- peek (#{ptr struct fsid, val[1]} ptr)
    return $ FsId first second
  poke ptr (FsId first second) = do
    poke (#{ptr struct fsid, val[0]} ptr) first
    poke (#{ptr struct fsid, val[1]} ptr) second

-- | Structure that uniquely identifies the file system object within
-- a mounted volume for the duration of it's mount.
--
-- Corresponds to @fsobj_id_t@ from @sys/_types/_fsobj_id_t.h@
--
-- According to @getattrlist@ man page @ATTR_CMN_OBJID@ is deprecated in favor
-- of @ATTR_CMNEXT_LINKID@ (sarting with macOS 10.13, iOS 11.0, watchOS 4.0
-- and tvOS 11.0), though it's not clear where to get replacements for
-- @ATTR_CMN_OBJPERMANENTID@ and @ATTR_CMN_PAROBJID@.
data FsObjId = FsObjId
  { fid_objno :: !Word32
  , fid_generation :: !Word32
  } deriving (Eq, Read, Show)

instance Storable FsObjId where
  sizeOf _ = #{size fsobj_id_t}
  alignment _ = #{alignment fsobj_id_t}
  peek ptr = do
    objNo <- #{peek fsobj_id_t, fid_objno} ptr
    generation <- #{peek fsobj_id_t, fid_generation} ptr
    return $ FsObjId { fid_objno = objNo, fid_generation = generation }
  poke ptr fsObjId = do
    #{poke fsobj_id_t, fid_objno} ptr (fid_objno fsObjId)
    #{poke fsobj_id_t, fid_generation} ptr (fid_generation fsObjId)

-- | A text encoding hint for the file system object's name.
-- From @sys/attr.h@.
-- Returned by 'getAttrList' for @ATTR_CMN_SCRIPT@.
-- Don't know how to interpret the values yet...
newtype TextEncoding =
  TextEncoding #{type text_encoding_t}
  deriving (Eq, Ord, Storable)
  deriving newtype (Read, Show)

-- | @__darwin_time_t@ from @machine/types.h@
newtype DarwinTime =
  DarwinTime #{type __darwin_time_t}
  deriving (Eq, Ord, Storable)
  deriving newtype (Read, Show)

-- | Corresponds to @struct timespec@ defined in @/sys/_types/_timespec.h@.
data TimeSpec = TimeSpec
  { tv_sec :: ! DarwinTime
  , tv_nsec :: ! #{type long}
  }
  deriving (Eq, Ord, Read, Show)

instance Storable TimeSpec where
  sizeOf _ = #{size _STRUCT_TIMESPEC}
  alignment _ = #{alignment _STRUCT_TIMESPEC}
  peek ptr = do
    sec <- #{peek _STRUCT_TIMESPEC, tv_sec} ptr
    nsec <- #{peek _STRUCT_TIMESPEC, tv_nsec} ptr
    return $ TimeSpec { tv_sec = sec, tv_nsec = nsec }
  poke ptr timespec = do
    #{poke _STRUCT_TIMESPEC, tv_sec} ptr (tv_sec timespec)
    #{poke _STRUCT_TIMESPEC, tv_nsec} ptr (tv_nsec timespec)

-- | "32 bytes of data for use by the Finder".
-- The interpretation depends on the FS object type (file or dir).
-- Returned by 'getAttrList' for @ATTR_CMN_FNDRINFO@.
-- [10.14] Hmm, it seems to always return 32 zero bytes so far...
newtype RawFinderInfo =
  RawFinderInfo BS.ByteString
  deriving (Read, Show)

instance Storable RawFinderInfo where
  sizeOf _ = 32
  alignment _ = 4
  peek ptr =
    RawFinderInfo <$> BS.packCStringLen ((castPtr ptr), 32)
  poke ptr (RawFinderInfo bs) =
    BS.useAsCStringLen bs $ \(buf, _) -> do
      copyBytes (castPtr ptr) buf 32

-- | File flags are returned in @st_flags@ field by @stat@ and for
-- @ATTR_CMN_FLAGS@ attr by @getAttrList@.
newtype FileFlags = FileFlags (EnumBitFlags Word32 FileFlag)
  deriving newtype (Show, Storable)

-- | 16 byte globally unique identifier.
--
newtype Guid =
  Guid String

instance Show Guid where
  show (Guid s) = hex s

instance Storable Guid where
  sizeOf _ = 16
  alignment _ = 1
  peek ptr =
    Guid <$> peekCStringLen ((castPtr ptr), 16)
  poke ptr (Guid s) =
    withCStringLen s $ \(sPtr, _) -> do
      copyBytes (castPtr ptr) sPtr 16

newtype Base2 a = Base2 a
  deriving newtype (Eq, Ord, Num, Enum, Real, Integral, Storable)

instance (Integral a, Show a) => Show (Base2 a) where
  showsPrec _ (Base2 x) = (showString "0b") . showIntAtBase 2 intToDigit x

-- | The Kauth* types below come from @sys/kauth.h@ which is marked as
-- @__APPLE_API_EVOLVING@ (as of 10.14).
-- There is also a public ACL API at @sys/acl.h@ (TODO) which is probably a
-- more stable way to deal with ACLs.

-- | @kauth_ace_rights_t@ from @sys/kauth.h@.
-- TODO: interpret
type KauthAceRights = #{type kauth_ace_rights_t}

-- | Access Control List Entry (ACE).
-- Corresponds to @struct kauth_ace@ from @sys/kauth.h@.
-- TODO: interpret flags and rights
data KauthAce = KauthAce
  { ace_applicable :: Guid
  , ace_flags :: Base2 Word32
  , ace_rights :: Base2 KauthAceRights
  }
  deriving (Show)

instance Storable KauthAce where
  sizeOf _ = #{const sizeof(struct kauth_ace)}
  alignment _ = 4
  peek ptr = do
    applicable <- #{peek struct kauth_ace, ace_applicable} ptr
    flags <- #{peek struct kauth_ace, ace_flags} ptr
    rights <- #{peek struct kauth_ace, ace_rights} ptr
    return $ KauthAce { ace_applicable = applicable
                      , ace_flags = flags
                      , ace_rights = rights }
  poke ptr ace = do
    #{poke struct kauth_ace, ace_applicable} ptr (ace_applicable ace)
    #{poke struct kauth_ace, ace_flags} ptr (ace_flags ace)
    #{poke struct kauth_ace, ace_rights} ptr (ace_rights ace)

-- | Access Control List.
-- Corresponds to @struct kauth_acl@ from @sys/kauth.h@.
-- TODO: interpret flags
data KauthAcl = KauthAcl
  { acl_flags :: Word32
  , acl_ace :: [KauthAce]
  }
  deriving (Show)

-- @struct kauth_acl@ is variable length, so it can't be Storable.
peekKauthAcl :: (Storable w) => Buf w -> IO (Buf w, KauthAcl)
peekKauthAcl buf@(Buf ptr _) = do
  aceBuf <- safeAdvance buf #{offset struct kauth_acl, acl_ace}
  (entrycount :: Word32) <- #{peek struct kauth_acl, acl_entrycount} ptr
  flags <- #{peek struct kauth_acl, acl_flags} ptr
  (aceBuf', ace) <- safePeekList aceBuf (fromEnum entrycount)
  return $ (aceBuf', KauthAcl { acl_flags = flags, acl_ace = ace })

-- | Extended File Security information.
-- Correponds to @struct kauth_filesec@ from @sys/kauth.h@.'
data KauthFilesec = KauthFilesec
  { fsec_magic :: Word32
  , fsec_owner :: Guid
  , fsec_group :: Guid
  , fsec_acl :: KauthAcl
  }
  deriving (Show)

peekKauthFilesec :: (Storable w) => Buf w -> IO (Buf w, KauthFilesec)
peekKauthFilesec buf@(Buf ptr _) = do
  aclBuf <- safeAdvance buf #{offset struct kauth_filesec, fsec_acl}
  (magic :: Word32) <- #{peek struct kauth_filesec, fsec_magic} ptr
  when (magic /= #{const KAUTH_FILESEC_MAGIC}) $
    error "wrong kauth_filesec magic"
  owner <- #{peek struct kauth_filesec, fsec_owner} ptr
  group <- #{peek struct kauth_filesec, fsec_group} ptr
  (buf', acl) <- peekKauthAcl aclBuf
  return $ (buf',
            KauthFilesec
              { fsec_magic = magic
              , fsec_owner = owner
              , fsec_group = group
              , fsec_acl = acl
              })
