{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE DerivingStrategies #-}

module Pavel.Xnu.Types
  ( FsId(..)
  , FsObjId(..)
  , TextEncoding(..)
  , DarwinTime(..)
  , TimeSpec(..)
  , RawFinderInfo
  , FileFlags
  , KauthAce(..)
  , KauthAcl(..)
  , KauthFilesec(..)
  , peekKauthAcl
  , peekKauthFilesec
  , FsOpt(..)  -- from CEnums.hs
  , VType(..)  -- from CEnums.hs
  , VTagType(..)  -- from CEnums.hs
  , FileFlag(..)  -- from CEnums.hs
  ) where

-------------------------------------------------------------------------------
-- | Types for interfacing with XNU. Only types that are used to prepare the
-- input, or interpret the output of XNU system calls should appear here.
--
-- Autogenerated enums are placed in a non-exposed Pavel.Xnu.Types.CEnums
-- (and reÃ«xported here) because it needs to be processed by a different
-- preprocessor (c2hs vs hsc2hs).
--
-- The "C" prefix should be only used if the type is involved in capi calls.
-- If in doubt, don't add "C" prefix. It can always be added later.
--
-- Struct field names, enum and constant names are preserved to make it easier
-- to cross reference them with man pages and C source.
--
-- Struct and enum names are converted to UpperCamelCase, with word boundaries
-- chosen intelligently. Established abbreviations (used in multiple places for
-- years) go as a single word, so they get only one capital letter
-- (Kauth, not KAuth; Id, not ID; Xnu, not XNU; etc).
--
-- This module should avoid defining types that are already defined in
-- 'System.Posix.Types' and other standard libraries.
-------------------------------------------------------------------------------

import Control.Monad
import Data.Bits
import qualified Data.ByteString as BS
import Data.Int
import Data.Word
import Foreign.Marshal.Utils
import Foreign.Ptr
import Foreign.Storable

import Pavel.EnumBitFlags
import Pavel.SafeBuf
import Pavel.Xnu.Types.CEnums

-- this needs to be included first for sys/acl.h to work
#include <sys/types.h>

#include <sys/_types/_fsid_t.h>
#include <sys/_types/_timespec.h>
#include <sys/acl.h>
#include <sys/attr.h>

-- | File system id type.
-- Corresponds to @struct fsid@ defined in
-- @sys/_types/_fsid_t.h@.
-- Returned by 'getAttrList' for @ATTR_CMN_FSID@.
data FsId =
  FsId !Int32 !Int32
  deriving (Eq, Ord, Read, Show)

instance Storable FsId where
  sizeOf _ = #{size struct fsid}
  alignment _ = #{alignment struct fsid}
  peek ptr = do
    first <- peek (#{ptr struct fsid, val[0]} ptr)
    second <- peek (#{ptr struct fsid, val[1]} ptr)
    return $ FsId first second
  poke ptr (FsId first second) = do
    poke (#{ptr struct fsid, val[0]} ptr) first
    poke (#{ptr struct fsid, val[1]} ptr) second

-- | Structure that uniquely identifies the file system object within
-- a mounted volume for the duration of it's mount.
--
-- Corresponds to @fsobj_id_t@ from @sys/_types/_fsobj_id_t.h@
--
-- According to @getattrlist@ man page @ATTR_CMN_OBJID@ is deprecated in favor
-- of @ATTR_CMNEXT_LINKID@ (sarting with macOS 10.13, iOS 11.0, watchOS 4.0
-- and tvOS 11.0), though it's not clear where to get replacements for
-- @ATTR_CMN_OBJPERMANENTID@ and @ATTR_CMN_PAROBJID@.
data FsObjId = FsObjId
  { fid_objno :: !Word32
  , fid_generation :: !Word32
  } deriving (Eq, Read, Show)

instance Storable FsObjId where
  sizeOf _ = #{size fsobj_id_t}
  alignment _ = #{alignment fsobj_id_t}
  peek ptr = do
    objNo <- #{peek fsobj_id_t, fid_objno} ptr
    generation <- #{peek fsobj_id_t, fid_generation} ptr
    return $ FsObjId { fid_objno = objNo, fid_generation = generation }
  poke ptr fsObjId = do
    #{poke fsobj_id_t, fid_objno} ptr (fid_objno fsObjId)
    #{poke fsobj_id_t, fid_generation} ptr (fid_generation fsObjId)

-- | A text encoding hint for the file system object's name.
-- From @sys/attr.h@.
-- Returned by 'getAttrList' for @ATTR_CMN_SCRIPT@.
-- Don't know how to interpret the values yet...
newtype TextEncoding =
  TextEncoding #{type text_encoding_t}
  deriving (Eq, Ord, Storable)
  deriving newtype (Read, Show)

-- | @__darwin_time_t@ from @machine/types.h@
newtype DarwinTime =
  DarwinTime #{type __darwin_time_t}
  deriving (Eq, Ord, Storable)
  deriving newtype (Read, Show)

-- | Corresponds to @struct timespec@ defined in @/sys/_types/_timespec.h@.
data TimeSpec = TimeSpec
  { tv_sec :: ! DarwinTime
  , tv_nsec :: ! #{type long}
  }
  deriving (Eq, Ord, Read, Show)

instance Storable TimeSpec where
  sizeOf _ = #{size _STRUCT_TIMESPEC}
  alignment _ = #{alignment _STRUCT_TIMESPEC}
  peek ptr = do
    sec <- #{peek _STRUCT_TIMESPEC, tv_sec} ptr
    nsec <- #{peek _STRUCT_TIMESPEC, tv_nsec} ptr
    return $ TimeSpec { tv_sec = sec, tv_nsec = nsec }
  poke ptr timespec = do
    #{poke _STRUCT_TIMESPEC, tv_sec} ptr (tv_sec timespec)
    #{poke _STRUCT_TIMESPEC, tv_nsec} ptr (tv_nsec timespec)

-- | "32 bytes of data for use by the Finder".
-- The interpretation depends on the FS object type (file or dir).
-- Returned by 'getAttrList' for @ATTR_CMN_FNDRINFO@.
-- [10.14] Hmm, it seems to always return 32 zero bytes so far...
newtype RawFinderInfo =
  RawFinderInfo BS.ByteString
  deriving (Read, Show)

instance Storable RawFinderInfo where
  sizeOf _ = 32
  alignment _ = 4
  peek ptr =
    RawFinderInfo <$> BS.packCStringLen ((castPtr ptr), 32)
  poke ptr (RawFinderInfo bs) =
    BS.useAsCStringLen bs $ \(buf, _) -> do
      copyBytes (castPtr ptr) buf 32

-- | File flags are returned in @st_flags@ field by @stat@ and for
-- @ATTR_CMN_FLAGS@ attr by @getAttrList@.
type FileFlags = EnumBitFlags Word32 FileFlag

-- | Apple-style globally unique identifier.
-- From @sys/_types/_guid_t.h@.
newtype Guid =
  Guid BS.ByteString
  deriving (Read, Show)

instance Storable Guid where
  sizeOf _ = #{const KAUTH_GUID_SIZE}
  alignment _ = 4
  peek ptr =
    Guid <$>
    BS.packCStringLen ((castPtr ptr), #{const KAUTH_GUID_SIZE})
  poke ptr (Guid bs) =
    BS.useAsCStringLen bs $ \(buf, _) -> do
      copyBytes (castPtr ptr) buf #{const KAUTH_GUID_SIZE}

-- | The Kauth* types below come from @sys/kauth.h@ which is marked as
-- @__APPLE_API_EVOLVING@ (as of 10.14).
-- There is also a public ACL API at @sys/acl.h@ (TODO) which is probably a
-- more stable way to deal with ACLs.

-- | @kauth_ace_rights_t@ from @sys/kauth.h@.
-- TODO: interpret
newtype KauthAceRights =
  KauthAceRights #{type kauth_ace_rights_t}
  deriving newtype (Bits, Eq, Enum, Show, Read, Storable)

-- | Access Control List Entry (ACE).
-- Corresponds to @struct kauth_ace@ from @sys/kauth.h@.
-- TODO: interpret flags and rights
data KauthAce = KauthAce
  { ace_applicable :: Guid
  , ace_flags :: Word32
  , ace_rights :: KauthAceRights
  }
  deriving (Read, Show)

instance Storable KauthAce where
  sizeOf _ = #{const sizeof(struct kauth_ace)}
  alignment _ = 4
  peek ptr = do
    applicable <- #{peek struct kauth_ace, ace_applicable} ptr
    flags <- #{peek struct kauth_ace, ace_flags} ptr
    rights <- #{peek struct kauth_ace, ace_rights} ptr
    return $ KauthAce { ace_applicable = applicable
                      , ace_flags = flags
                      , ace_rights = rights }
  poke ptr ace = do
    #{poke struct kauth_ace, ace_applicable} ptr (ace_applicable ace)
    #{poke struct kauth_ace, ace_flags} ptr (ace_flags ace)
    #{poke struct kauth_ace, ace_rights} ptr (ace_rights ace)

-- | Access Control List.
-- Corresponds to @struct kauth_acl@ from @sys/kauth.h@.
-- TODO: interpret flags
data KauthAcl = KauthAcl
  { acl_flags :: Word32
  , acl_ace :: [KauthAce]
  }
  deriving (Read, Show)

-- @struct kauth_acl@ is variable length, so it can't be Storable.
peekKauthAcl :: (Storable w) => Buf w -> IO (Buf w, KauthAcl)
peekKauthAcl buf@(Buf ptr _) = do
  aceBuf <- safeAdvance buf #{offset struct kauth_acl, acl_ace}
  (entrycount :: Word32) <- #{peek struct kauth_acl, acl_entrycount} ptr
  flags <- #{peek struct kauth_acl, acl_flags} ptr
  (aceBuf', ace) <- safePeekList aceBuf (fromEnum entrycount)
  return $ (aceBuf', KauthAcl { acl_flags = flags, acl_ace = ace })

-- | Extended File Security information.
-- Correponds to @struct kauth_filesec@ from @sys/kauth.h@.'
data KauthFilesec = KauthFilesec
  { fsec_magic :: Word32
  , fsec_owner :: Guid
  , fsec_group :: Guid
  , fsec_acl :: KauthAcl
  }
  deriving (Read, Show)

peekKauthFilesec :: (Storable w) => Buf w -> IO (Buf w, KauthFilesec)
peekKauthFilesec buf@(Buf ptr _) = do
  aclBuf <- safeAdvance buf #{offset struct kauth_filesec, fsec_acl}
  (magic :: Word32) <- #{peek struct kauth_filesec, fsec_magic} ptr
  when (magic /= #{const KAUTH_FILESEC_MAGIC}) $
    error "wrong kauth_filesec magic"
  owner <- #{peek struct kauth_filesec, fsec_owner} ptr
  group <- #{peek struct kauth_filesec, fsec_group} ptr
  (buf', acl) <- peekKauthAcl aclBuf
  return $ (buf',
            KauthFilesec
              { fsec_magic = magic
              , fsec_owner = owner
              , fsec_group = group
              , fsec_acl = acl
              })
